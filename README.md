# SWE_Practical_Works
# lab 2
I learned effective file handling and error management using context managers and exception handling. String manipulation skills were enhanced through text cleaning and normalization techniques. Utilizing data structures like lists and sets improved my ability to manage and analyze word data, while the Counter class simplified frequency counting. Breaking the program into modular functions promoted reusability and maintainability. Finally, I grasped the importance of formatted output and thorough testing to ensure reliable code functionality.

# lab 3
 I learned the importance of modular function design and efficient iterative approaches over recursion. Handling edge cases and writing test cases reinforced the necessity of robustness in code. Additionally, I recognized the value of clear documentation for maintainability and clarity.

# lab 4
I learned how linear search is straightforward but less efficient for large datasets compared to binary and jump searches. The importance of sorting an array before applying binary search became clear, as it relies on the data being ordered. Additionally, counting comparisons provided insight into the algorithms' performance metrics. Finally, creating a structured comparison function helped me grasp the practical implications of each algorithm's efficiency in real-world scenarios.

# lab 5
I learned how postfix notation simplifies the evaluation of arithmetic expressions, allowing for a straightforward stack-based approach. Creating a queue using two stacks highlighted the versatility of stacks in simulating other data structures. The task scheduler demonstrated how to manage a list of tasks using a simple LIFO structure, emphasizing the importance of organization in programming. I also gained insights into operator precedence through the infix-to-postfix conversion, which is essential for correctly parsing mathematical expressions. This implementation reinforced the importance of error handling to ensure robustness, particularly in stack operations and expression evaluations. Additionally, I realized the value of thorough testing to validate the functionality of each component. Overall, this exercise improved my problem-solving skills and understanding of algorithm design.

# lab 6
I learned how postfix notation simplifies the evaluation of arithmetic expressions, allowing for a straightforward stack-based approach. Creating a queue using two stacks highlighted the versatility of stacks in simulating other data structures. The task scheduler demonstrated how to manage a list of tasks using a simple LIFO structure, emphasizing the importance of organization in programming. I also gained insights into operator precedence through the infix-to-postfix conversion, which is essential for correctly parsing mathematical expressions. This implementation reinforced the importance of error handling to ensure robustness, particularly in stack operations and expression evaluations. Additionally, I realized the value of thorough testing to validate the functionality of each component. Overall, this exercise improved my problem-solving skills and understanding of algorithm design.

# lab 7
I learned how to construct a BST by recursively inserting nodes, ensuring that each node's left children are smaller and right children are larger. The methods for finding the maximum value and counting nodes illustrated the importance of traversal techniques in tree manipulation. I gained practical experience with breadth-first search through level-order traversal using a queue, enhancing my problem-solving skills. Additionally, implementing the height calculation deepened my appreciation for tree depth and structure. The validation of the BST properties highlighted the critical nature of maintaining tree integrity. Overall, this exercise improved my understanding of recursion and its application in data structure operations.

# lab 8
I learned how to optimize bubble sort by using a swap flag to enhance its efficiency. The concept of recursion was reinforced through the implementation of both quick sort and merge sort, highlighting the importance of base cases and partitioning in sorting. Additionally, the use of insertion sort for smaller subarrays in the hybrid sort demonstrated a practical approach to improving performance for specific conditions. Creating a visualization of bubble sort provided insight into algorithm behavior during execution. I also recognized the significance of testing and comparing algorithm performance on random datasets. Overall, this exercise improved my coding skills and understanding of algorithm efficiency.

# lab 9
I learned how Dijkstra's algorithm operates with priority queues to handle weighted graphs and how to check for bipartiteness through graph coloring. Structuring the code in a Graph class improved modularity and readability, emphasizing good software design practices. The practical tests reinforced the importance of validating algorithm implementations.